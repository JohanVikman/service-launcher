module esc_types {
  // Generated by yanger -t ncs
  tailf:ncs-device-type "netconf";

  namespace "http://www.cisco.com/esc/esc_types";
  prefix types;

  import ietf-inet-types {
    prefix ietf-inet-types;
  }
  import ietf-yang-types {
    prefix ietf-yang-types;
  }
  import tailf-ncs {
    prefix ncs;
  }
  import tailf-common {
    prefix tailf;
  }

  organization "Cisco Systems";
  contact
    "Shesha Sreenivasamurthy <shesha@cisco.com>";
  description
    "ESC's types declarations";

  revision 2016-12-02 {
    description
      "Normalize new LCS policy names";
  }
  revision 2016-11-22 {
    description
      "Make some additions and modifications to log_classification_types and log_tag_types.";
  }
  revision 2016-11-08 {
    description
      "Add new enums log_level_type and log_tag_type for filter logs api.";
  }
  revision 2016-10-06 {
    description
      "Add new new event types for vim connector and user create/delete/update.";
  }
  revision 2016-09-30 {
    description
      "Add new vim_type AWS_EC2, and update vim_type.";
  }
  revision 2016-09-23 {
    description
      "Add new enum vim_type";
  }
  revision 2016-07-21 {
    description
      "Add template_engine_type enum";
  }
  revision 2016-06-28 {
    description
      "Remove unsupported enum STRING from metric_types";
  }
  revision 2016-04-29 {
    description
      "Added a new event type VM_MANUAL_RECOVERY_NO_NEED";
  }
  revision 2016-04-13 {
    description
      "Defined a new enum policy_condition_type";
  }
  revision 2016-03-29 {
    description
      "Added a new event type VM_MANUAL_RECOVERY_NEEDED";
  }
  revision 2016-03-11 {
    description
      "Added a new style type for recovery";
  }
  revision 2016-03-01 {
    description
      "Added a new operation type for recovering on manual";
  }
  revision 2016-01-22 {
    description
      "Added a new event type VM_RECOVERY_CANCELLED and VM_RECOVERY_REBOOT";
  }
  revision 2015-11-05 {
    description
      "Remove EiB support for volumes";
  }
  revision 2015-09-21 {
    description
      "Added a leaf to config if redeploy is needed after reboot fails upon recovery";
  }
  revision 2015-08-21 {
    description
      "Removed union types for xpaths";
  }
  revision 2015-07-30 {
    description
      "Added new enum types in iface_type to support sr-iov";
  }
  revision 2015-07-24 {
    description
      "Added host_placement and zone_placement to placement_type";
  }
  revision 2015-07-23 {
    description
      "Added event type VM_UPDATED. Revision header update in data model.";
  }
  revision 2015-07-14 {
    description
      "Added VIM_OPERATIONAL_STATE and removed ESC_IN_SERVICE and ESC_OUT_OF_SERVICE.";
  }
  revision 2015-06-29 {
    description
      "ESC Types added for create/delete image/flavor";
  }
  revision 2015-06-08 {
    description
      "added types escuint8, escuint16, escuint32 for esc_port_forwarding";
  }
  revision 2014-06-23 {
    description
      "ESC Types";
  }

  typedef vim_type {
    description
      "Vim types";
    type enumeration {
      enum "OPENSTACK";
      enum "LIBVIRT";
      enum "VMWARE_VSPHERE";
      enum "AWS_EC2";
    }
  }

  typedef template_engine_type {
    description
      "Config data (template file) template engine type";
    type enumeration {
      enum "VELOCITY";
      enum "NONE";
    }
  }

  typedef policy_condition_type {
    description
      "Policy condition types";
    type enumeration {
      enum "LCS::PRE_DEPLOY";
      enum "LCS::POST_DEPLOY_ALIVE";
      enum "LCS::DEPLOY_ERR";
      enum "LCS::POST_DEPLOY::VM_RECOVERY_ERR";
      enum "LCS::POST_DEPLOY::VM_RECOVERY_REDEPLOY_ERR";
      enum "LCS::DEPLOY::PRE_SERVICE_DEPLOY_INIT";
      enum "LCS::DEPLOY::PRE_VM_DEPLOY";
      enum "LCS::DEPLOY::POST_VM_DEPLOYED";
      enum "LCS::DEPLOY::POST_VM_DEPLOY_ERR";
      enum "LCS::DEPLOY::POST_VM_ALIVE";
      enum "LCS::DEPLOY::POST_SERVICE_DEPLOYED";
      enum "LCS::DEPLOY::POST_SERVICE_DEPLOY_ERR";
      enum "LCS::DEPLOY_UPDATE::PRE_SERVICE_UPDATE_INIT";
      enum "LCS::DEPLOY_UPDATE::PRE_VM_DEPLOY";
      enum "LCS::DEPLOY_UPDATE::POST_VM_DEPLOYED";
      enum "LCS::DEPLOY_UPDATE::POST_VM_DEPLOY_ERR";
      enum "LCS::DEPLOY_UPDATE::POST_VM_ALIVE";
      enum "LCS::DEPLOY_UPDATE::PRE_VM_UPDATE";
      enum "LCS::DEPLOY_UPDATE::POST_VM_UPDATED";
      enum "LCS::DEPLOY_UPDATE::POST_VM_UPDATE_ERR";
      enum "LCS::DEPLOY_UPDATE::PRE_VM_UNDEPLOY";
      enum "LCS::DEPLOY_UPDATE::POST_VM_UNDEPLOYED";
      enum "LCS::DEPLOY_UPDATE::POST_SERVICE_UPDATED";
      enum "LCS::DEPLOY_UPDATE::POST_SERVICE_UPDATE_ERR";
      enum "LCS::UNDEPLOY::PRE_SERVICE_UNDEPLOY_INIT";
      enum "LCS::UNDEPLOY::PRE_VM_UNDEPLOY";
      enum "LCS::UNDEPLOY::POST_VM_UNDEPLOYED";
      enum "LCS::UNDEPLOY::POST_VM_UNDEPLOY_ERR";
      enum "LCS::UNDEPLOY::POST_SERVICE_UNDEPLOYED";
      enum "LCS::UNDEPLOY::POST_SERVICE_UNDEPLOY_ERR";
      enum "LCS::POST_DEPLOY::PRE_VM_RECOVERY_INIT";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_REBOOTED";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_DEPLOYED";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_COMPLETE";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_ERR";
      enum "LCS::POST_DEPLOY::PRE_VM_RECOVERY_REDEPLOY_INIT";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_REDEPLOY_DEPLOYED";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_REDEPLOY_COMPLETE";
      enum "LCS::POST_DEPLOY::POST_VM_RECOVERY_REDEPLOY_ERR";
      enum "LCS::VM_SCALE_OUT::PRE_VM_SCALE_OUT_INIT";
      enum "LCS::VM_SCALE_OUT::PRE_VM_DEPLOY";
      enum "LCS::VM_SCALE_OUT::POST_VM_DEPLOYED";
      enum "LCS::VM_SCALE_OUT::POST_VM_DEPLOY_ERR";
      enum "LCS::VM_SCALE_OUT::POST_VM_ALIVE";
      enum "LCS::VM_SCALE_OUT::POST_VM_SCALE_OUT_COMPLETE";
      enum "LCS::VM_SCALE_OUT::POST_VM_SCALE_OUT_ERR";
      enum "LCS::VM_SCALE_IN::PRE_VM_SCALE_IN_INIT";
      enum "LCS::VM_SCALE_IN::PRE_VM_UNDEPLOY";
      enum "LCS::VM_SCALE_IN::POST_VM_UNDEPLOYED";
      enum "LCS::VM_SCALE_IN::POST_VM_UNDEPLOY_ERR";
      enum "LCS::VM_SCALE_IN::POST_VM_SCALE_IN_COMPLETE";
      enum "LCS::VM_SCALE_IN::POST_VM_SCALE_IN_ERR";
      enum "LCS::VM::PRE_VM_DEPLOY";
      enum "LCS::VM::POST_VM_DEPLOYED";
      enum "LCS::VM::POST_VM_DEPLOY_ERR";
      enum "LCS::VM::POST_VM_ALIVE";
      enum "LCS::VM::PRE_VM_UNDEPLOY";
      enum "LCS::VM::POST_VM_UNDEPLOYED";
      enum "LCS::VM::POST_VM_UNDEPLOY_ERR";
      enum "LCS::DEPLOY_UPDATE::PRE_VM_SOFTWARE_VERSION_UPDATE";
      enum "LCS::DEPLOY_UPDATE::POST_VM_SOFTWARE_VERSION_UPDATED";
      enum "LCS::DEPLOY_UPDATE::PRE_VM_VOLUME_DETACH";
      enum "LCS::DEPLOY_UPDATE::POST_VM_VOLUME_DETACHED";
      enum "LCS::DEPLOY_UPDATE::PRE_VM_VOLUME_ATTACH";
      enum "LCS::DEPLOY_UPDATE::POST_VM_VOLUME_ATTACHED";
    }
  }

  typedef life_cycle_stage_type {
    description
      "Life-cycle stage types";
    type enumeration {
      enum "PRE_DEP";
      enum "POST_DEP";
      enum "DEP_ERROR";
      enum "PRE_UNDEP";
      enum "POST_UNDEP";
      enum "VM_RECOVERY_ERROR";
      enum "VM_RECOVERY_REDEPLOY_ERROR";
    }
  }

  typedef log_tag_types {
    description
      "Log tags that can be specified as part of a filter in the filterLog rpc request.";
    type enumeration {
      enum "wf";
      enum "eventType";
      enum "tenant";
      enum "network";
      enum "subnet";
      enum "user";
      enum "image";
      enum "flavor";
      enum "depName";
      enum "vmGrpName";
      enum "vmName";
      enum "switch";
      enum "volumeId";
      enum "svcName";
      enum "escTransactionId";
      enum "externalTenantId";
      enum "internalTenantId";
      enum "operationType";
      enum "threadName";
      enum "stateMachineContextId";
      enum "stateMachineType";
    }
  }

  typedef log_classification_types {
    description
      "Log classifications that can be specified as part of a filter in the filterLog rpc request.";
    type enumeration {
      enum "NBI";
      enum "SBI";
      enum "SM";
      enum "MONITORING";
      enum "DYNAMIC_MAPPING";
      enum "CONFD";
      enum "CONFD_NOTIFICATION";
      enum "OS";
      enum "LIBVIRT";
      enum "VIM";
      enum "REST_EVENT";
      enum "WD";
      enum "DM";
      enum "DB";
      enum "GW";
      enum "LC";
      enum "SEC";
      enum "MOCONFIG";
      enum "POLICY";
      enum "TP";
      enum "ESC";
    }
  }

  typedef log_level_types {
    description
      "Log levels that can be specified as part of filter in the filterLog rpc request.";
    type enumeration {
      enum "ERROR";
      enum "INFO";
      enum "WARN";
      enum "TRACE";
      enum "DEBUG";
      enum "FATAL";
    }
  }

  typedef host_action_type {
    description
      "Host action types";
    type enumeration {
      enum "ENABLE";
      enum "DISABLE";
    }
  }

  typedef recovery_op_types {
    description
      "Recovery VM operation types";
    type enumeration {
      enum "DO";
      enum "DONOT";
    }
  }

  typedef recovery_style_types {
    description
      "Recovery style types";
    type enumeration {
      enum "AUTO";
      enum "MANUAL";
    }
  }

  typedef recovery_action_types {
    description
      "Recovery action types";
    type enumeration {
      enum "REBOOT_THEN_REDEPLOY";
      enum "REBOOT_ONLY";
      enum "REDEPLOY_ONLY";
    }
  }

  typedef action_types {
    description
      "Service/VM action types";
    type enumeration {
      enum "STOP";
      enum "START";
      enum "REBOOT";
      enum "DISABLE_MONITOR";
      enum "ENABLE_MONITOR";
      enum "DEPLOYMENT_RECOVERY";
    }
  }

  typedef vm_group_properties {
    description
      "vm_group_properties";
    type enumeration {
      enum "NOTIFY_EXTERNAL_MONITOR";
    }
  }

  typedef vm_state_machine_states {
    description
      "VM state machines states";
    type enumeration {
      enum "VM_UNDEF_STATE";
      enum "VM_DEPLOYING_STATE";
      enum "VM_MONITOR_UNSET_STATE";
      enum "VM_MONITOR_DISABLED_STATE";
      enum "VM_STOPPING_STATE";
      enum "VM_SHUTOFF_STATE";
      enum "VM_STARTING_STATE";
      enum "VM_REBOOTING_STATE";
      enum "VM_INERT_STATE";
      enum "VM_ALIVE_STATE";
      enum "VM_UNDEPLOYING_STATE";
      enum "VM_ERROR_STATE";
    }
  }

  typedef service_state_machine_states {
    description
      "Service state machines states";
    type enumeration {
      enum "SERVICE_UNDEF_STATE";
      enum "SERVICE_DEPLOYING_STATE";
      enum "SERVICE_INERT_STATE";
      enum "SERVICE_ACTIVE_STATE";
      enum "SERVICE_UNDEPLOYING_STATE";
      enum "SERVICE_STOPPING_STATE";
      enum "SERVICE_STOPPED_STATE";
      enum "SERVICE_STARTING_STATE";
      enum "SERVICE_REBOOTING_STATE";
      enum "SERVICE_ERROR_STATE";
    }
  }

  typedef flavor_state_machine_states {
    description
      "VM state machines states";
    type enumeration {
      enum "FLAVOR_UNDEF_STATE";
      enum "FLAVOR_CREATING_STATE";
      enum "FLAVOR_ACTIVE_STATE";
      enum "FLAVOR_DELETING_STATE";
      enum "FLAVOR_DELETED_STATE";
      enum "FLAVOR_ERROR_STATE";
    }
  }

  typedef image_state_machine_states {
    description
      "VM state machines states";
    type enumeration {
      enum "IMAGE_UNDEF_STATE";
      enum "IMAGE_CREATING_STATE";
      enum "IMAGE_ACTIVE_STATE";
      enum "IMAGE_DELETING_STATE";
      enum "IMAGE_DELETED_STATE";
      enum "IMAGE_ERROR_STATE";
    }
  }

  typedef enforcement {
    description
      "Whether the affinity policy should be strictly or loosely enforced";
    type enumeration {
      enum "strict";
    }
  }

  typedef placement_type {
    description
      "Whether VMs of two groups to be place together (affinity) or on separate
       hosts (anti_affinity), also whether VMs should be placed on a host or in a zone";
    type enumeration {
      enum "affinity";
      enum "anti_affinity";
      enum "zone_host";
    }
  }

  typedef wd_action {
    description
      "Action that should be taken by the hypervisor when watchdog
       is triggered";
    type enumeration {
      enum "reset";
      enum "poweroff";
      enum "shutdown";
      enum "pasue";
      enum "debug";
      enum "none";
    }
  }

  typedef wd_hardware {
    description
      "Only certain Watchdog hardware are supported current.";
    type enumeration {
      enum "i6300esb";
      enum "ib700";
    }
  }

  typedef pollunits {
    description
      "Polling units, seconds or minutes";
    type enumeration {
      enum "minutes";
      enum "seconds";
    }
  }

  typedef metric_types {
    description
      "Different conditions supported with respect to metric comparison";
    type enumeration {
      enum "INT8";
      enum "INT16";
      enum "INT32";
      enum "UINT8";
      enum "UINT16";
      enum "UINT32";
      enum "FLOAT";
      enum "DOUBLE";
    }
  }

  typedef conditions {
    description
      "Different conditions supported with respect to metric comparison";
    type enumeration {
      enum "GT";
      enum "LT";
      enum "EQ";
      enum "GE";
      enum "LE";
    }
  }

  typedef disk_formats {
    description
      "The format of the disk that is being specified as disk source.
       Currently QCOW2, RAW and VMDK formats are supported.";
    type enumeration {
      enum "qcow2";
      enum "raw";
      enum "vmdk";
    }
  }

  typedef ipversion_t {
    description
      "ipv4 or ipv6";
    type enumeration {
      enum "ipv4";
      enum "ipv6";
    }
  }

  typedef iface_model {
    description
      "Virtual Interface Type: virtio, e1000 etc. Later when we support
       'passthru' interface type we can change this to a union";
    type enumeration {
      enum "e1000";
      enum "ne2k_pci";
      enum "virtio";
      enum "i82551";
      enum "i82557b";
      enum "i82559er";
      enum "rtl8139";
      enum "pcnet";
    }
  }

  typedef iface_type {
    description
      "Interface Type: VIRTUAL/PASSTHRU";
    type enumeration {
      enum "virtual";
      enum "passthru";
      enum "direct";
      enum "macvtap";
    }
  }

  typedef iobus {
    description
      "PCI bus interface that is to be used while attaching the OS
       disk to the domain. Currently supported bus types are IDE,
       SCSI and VIRTIO";
    type enumeration {
      enum "ide";
      enum "scsi";
      enum "virtio";
    }
  }

  typedef szunits {
    description
      "Some standard size units: MiB, GiB, TiB and PiB
              MiB: 1024^2 (Mebibyte)
              GiB: 1024^3 (Gibibyte)
              TiB: 1024^4 (Tebibyte)
              PiB: 1024^5 (Pebibyte)";
    type enumeration {
      enum "MiB";
      enum "GiB";
      enum "TiB";
      enum "PiB";
    }
  }

  typedef status {
    type enumeration {
      enum "SUCCESS";
      enum "FAILURE";
    }
  }

  typedef event_types {
    type enumeration {
      enum "CREATE_NETWORK";
      enum "DELETE_NETWORK";
      enum "CREATE_SUBNET";
      enum "DELETE_SUBNET";
      enum "CREATE_TENANT";
      enum "DELETE_TENANT";
      enum "CREATE_IMAGE";
      enum "DELETE_IMAGE";
      enum "CREATE_FLAVOR";
      enum "DELETE_FLAVOR";
      enum "SERVICE_REGISTRATION";
      enum "SERVICE_UNREGISTRATION";
      enum "VM_DEPLOYED";
      enum "VM_ALIVE";
      enum "VM_UPDATED";
      enum "VM_UNDEPLOYED";
      enum "SERVICE_ALIVE";
      enum "SERVICE_UNDEPLOYED";
      enum "VM_SCALE_OUT_INIT";
      enum "VM_SCALE_OUT_DEPLOYED";
      enum "VM_SCALE_OUT_COMPLETE";
      enum "VM_SCALE_IN_INIT";
      enum "VM_SCALE_IN_COMPLETE";
      enum "VM_RECOVERY_INIT";
      enum "VM_RECOVERY_DEPLOYED";
      enum "VM_RECOVERY_UNDEPLOYED";
      enum "VM_RECOVERY_COMPLETE";
      enum "SERVICE_UPDATED";
      enum "VM_STOPPED";
      enum "SERVICE_STOPPED";
      enum "VM_STARTED";
      enum "SERVICE_STARTED";
      enum "VM_REBOOTED";
      enum "SERVICE_REBOOTED";
      enum "VM_MONITOR_UNSET";
      enum "SERVICE_MONITOR_UNSET";
      enum "VM_MONITOR_SET";
      enum "VIM_OPERATIONAL_STATE";
      enum "VM_RECOVERY_CANCELLED";
      enum "VM_RECOVERY_REBOOT";
      enum "HOST_ENABLE";
      enum "HOST_DISABLE";
      enum "VM_MANUAL_RECOVERY_NEEDED";
      enum "VM_MANUAL_RECOVERY_NO_NEED";
      enum "CREATE_VIM_CONNECTOR";
      enum "DELETE_VIM_CONNECTOR";
      enum "UPDATE_VIM_CONNECTOR";
      enum "CREATE_VIM_USER";
      enum "DELETE_VIM_USER";
      enum "UPDATE_VIM_USER";
      enum "VM_SOFTWARE_VERSION_UPDATED";
      enum "LCS_NOTIFY";
    }
  }

  typedef license_key_value {
    type string {
      length "1..256";
    }
  }

  typedef license_key_type {
    type enumeration {
      enum "mac_addr";
    }
  }

  typedef escmacaddr {
    type ietf-yang-types:mac-address;
  }

  typedef esc_ip_prefix {
    type string {
      pattern '(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8]))';
    }
  }

  typedef escipaddr {
    type ietf-inet-types:ip-address;
  }

  typedef escbigdata {
    type string {
      length "1..16384";
    }
  }

  typedef escnetname {
    type string {
      length "1..1024";
    }
  }

  typedef escversion {
    type string {
      length "1..16";
    }
  }

  typedef escname {
    type string {
      length "1..256";
    }
  }

  typedef escfloat {
    type string;
    reference "http://www.w3.org/TR/xmlschema-2/#float";
  }
}
